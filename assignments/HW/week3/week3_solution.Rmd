---
title: "Homework 3"
author: "BIOF 339"
output: html_document
---

```{r setup, include=F}
knitr::opts_chunk$set(warnings=F, message=F,
                      fig.height=4)
library(tidyverse)
library(rio)
library(here)
```

<div style="color: black; border:3px; border-style: solid; border-color: red;padding: 1em; background-color: wheat;font-size: 14pt;">

Instructions:

I suggest you start working on this week's assignment using just a R script file, and work out the different things you have to do using just R code. 

The submission, of course, has to be a R Markdown file and the corresponding knitted HTML file. You will create this R Markdown file on your own, adding R chunks in it with code copied from your scirpt file. You also have to write in the question numbers and a minimal narrative in markdown as part of the R Markdown file, so that it reads more like a report. 

The submission will consist of your R markdown file and knitted HTML file. You have to make 
sure that the HTML file is properly rendered. **Both files are required, and omitting one is an incomplete assignment**

Also, please remove any and all template-based text from the R markdown file before you submit it. We don't want to see the template materials in any submissions. 
</div>

## Reading

1. Please read [Chapter 3](https://r4ds.had.co.nz/data-visualisation.html#introduction-1) 
of R4DS. This is a really nice reference. If you're interested, look at [section 3.7](https://r4ds.had.co.nz/data-visualisation.html#statistical-transformations) for a deeper understanding of how different statistical transformations can be accommodated within different geometries in ggplot2. 

## Exercises

<ol>
<li> Let's look at the  [breast cancer data set](data/clinical_data_breast_cancer_hw.csv) we'be been using.  
```{r}
library(rio)
brca <- import(here('data/brca_data.rds')) %>% 
  janitor::clean_names()
```

<ol>
  <li> Create a bar plot of the frequencies of ER status (Hint: `geom_bar`. How would you modify the dataset
  so that there is no separate bar for NA's?
```{r}
ggplot(brca, aes(x = er_status))+
  geom_bar()
```
```{r}
ggplot(brca %>% filter(!is.na(er_status)),
       aes(x = er_status))+
  geom_bar()
```
  
  <li> Color each bar by the frequencies of HER2 status within each group. (Hint: you can add `aes(color='HER2.Status')` or `aes(fill='HER2.Status')` to the `geom_bar` statement. What is the difference in these two choices?)
```{r}
ggplot(brca %>% filter(!is.na(er_status), !is.na(her2_final_status)),
       aes(x = er_status, fill=her2_final_status))+
  geom_bar(position = 'stack') # This is the default
```

  <li> I would like to see a graph showing the relative frequencies of HER2 status within each ER group. Read the documentation `?geom_bar` as well as section 3.8 of R4DS to find this solution. 
```{r}
ggplot(brca %>% filter(!is.na(er_status), !is.na(her2_final_status)),
       aes(x = er_status, fill=her2_final_status))+
  geom_bar(position = 'fill')+ # This is the default
  scale_y_continuous('Percent', labels = scales::label_percent())+
  labs(x = 'ER status', fill = 'HER2 status')
```

</ol>

<li> The `diamonds` dataset is included in the `ggplot2` package. 
<ol>
<li> Add a column to the diamonds dataset that is the volume of each diamond (multiplying the `x`, `y` and `z` variables)
```{r}
diamonds1 <- diamonds %>% mutate(volume = x * y * z)
```

<li> Plot a scatter plot of diamond price against diamond volume
```{r}
ggplot(diamonds1, aes(x=volume, y=price))+
  geom_point()
```

<li> Modify the plot to add colors based on the cut of each diamond
```{r}
ggplot(diamonds1, aes(x=volume, y = price))+
  geom_point(aes(color=cut))
```

<li> Modify the previous plot to construct a facetted plot where each facet is based on a color.
```{r}
ggplot(diamonds1, aes(x = volume, y = price))+
  geom_point()+
  facet_wrap(~cut)
```

</ol>



<li> The following links provide data for U.S. incidence rates per 100,000, standardized to the 2000 standard U.S. population,  for 
[brain](data/HW6/Brain.csv), [colon](data/HW6/Colon.csv), [esophageal](data/HW6/Esophagus.csv), [lung](data/HW6/Lung.csv) and [oral](data/HW6/Oral.csv) cancers for the period 1975-2016. These data/HW6 are provided from the [SEER program](https://seer.cancer.gov){target=_blank}. 

Our goal is to create a single graphic showing the patterns of incidence rates over this time period for the 5 cancers, something like the one below: 

![](../img/hw6.png)

1. Each csv file is in the same format. Open one in a text editor like Notepad (Windows) or TextEdit (Mac) to see lines you may need to skip. (I don't suggest Excel since it has a habit of changing formating and adding columns when you save back into csv). Then read each of the five files into R. For convenience I'll refer to these datasets as `brain`, `colon`, `esophagus`, `lung` and `oral`.
    - Confirm that each dataset has 43 rows and 10 columns
  ```{r}
  library(tidyverse)
  library(rio)
  library(here)
  
  brain <- import(here('data/Brain.csv'), skip=4)
  colon <- import(here('data/Colon.csv'), skip=4)
  esophagus <- import(here('data/Esophagus.csv'), skip=4)
  lung <- import(here('data/Lung.csv'), skip=4)
  oral <- import(here('data/Oral.csv'), skip=4)

  str(brain)
  str(colon)
  ```   

1. Create three separate datasets for each site, one for both sexes, one for males and one for females. Each dataset should still have year of diagnosis. So each dataset should have 43 rows and 4 columns.
  ```{r}
  brain_both_sexes <- select(brain, `Year of Diagnosis`, ends_with('Sexes'))
  brain_male <- select(brain, `Year of Diagnosis`, ends_with('Males'))
  brain_female <- select(brain, `Year of Diagnosis`, ends_with('Females'))
  
  str(brain_both_sexes)
  str(brain_male)
  str(brain_female)
  
  colon_both_sexes <- select(colon, `Year of Diagnosis`, ends_with('Sexes'))
  esophagus_both_sexes <- select(esophagus, `Year of Diagnosis`, ends_with('Sexes'))
  lung_both_sexes <- select(lung, `Year of Diagnosis`, ends_with('Sexes'))
  oral_both_sexes <- select(oral, `Year of Diagnosis`, ends_with('Sexes'))
  ```
  
<li> For the next few points, I will refer to the both sexes datasets. You'll do the same for the male and female datasets.

1. Each dataset has the same column headers. We'll be joining the data sets into a single data set using the year of diagnosis as the **key**, i.e. the common variable that will determine the joins. This means we have to make the column names for the different data sets (except the year column) distinctive. Change the column names replacing `both_sexes` with the names of the cancer sites
    - *Hints: `names(brain)` gives the column names for the brain data. You can also change column names using `names(brain) <- ...` since this is just a vector. In particular, you can try something like `names(brain) <- stringr::str_replace(names(brain), 'both_sexes', 'brain')`*
  ```{r}
  names(brain_both_sexes) <- str_replace(names(brain_both_sexes), 'Both Sexes','brain')
  names(colon_both_sexes) <- str_replace(names(colon_both_sexes), 'Both Sexes','colon')
  names(esophagus_both_sexes) <- str_replace(names(esophagus_both_sexes), 'Both Sexes','esophagus')
  names(lung_both_sexes) <- str_replace(names(lung_both_sexes), 'Both Sexes','lung')
  names(oral_both_sexes) <- str_replace(names(oral_both_sexes), 'Both Sexes','oral')
  ```
  
<li> Create a new composite dataset by repeatedly using `left_join` or `inner_join` to add each site-specific dataset to the composite data set. What I mean is, create a dataset joining A and B, then join C to the result, then join D to the result and so on.
  ```{r}
  both_sexes <- brain_both_sexes %>% left_join(colon_both_sexes) %>% 
    left_join(esophagus_both_sexes) %>% 
    left_join(lung_both_sexes) %>% 
    left_join(oral_both_sexes)
  ```


1. For each of these datasets:
    a. Remove the row with the overall 1975-2016 rates
    b. Use `pivot_longer` to make a dataset with 3 columns: year, type of cancer and cancer incidence rate

```{r}
both_sexes <- both_sexes %>% 
    slice(-1) %>% 
    mutate(across(everything(), as.numeric)) %>% 
    pivot_longer(names_to = 'race_site', 
                 values_to = 'rate',
                 cols = c(-`Year of Diagnosis`)) %>% 
    separate(race_site, c('race','site'), sep=',')

```

<li> Create 3 plots like the one above, one for all races, one for whites and one for blacks. Assign the ggplot code for each to a name, i.e. something like `plt1 <- ggplot(...) + ...`. Display the graph for all races, and create and display a panelled plot where the white and black plots are presented side-by-side. You can use functions from **cowplot**, **ggpubr** or **patchwork** as you like.
    
1. Make sure you have labelled everything properly, including titles, so that the graphical information is self-evident.
```{r, fig.height=6, fig.width=6}
plt1 <- both_sexes %>% filter(race=='All Races') %>% 
    ggplot(aes(x = `Year of Diagnosis`, y  = rate, color = site))+
    geom_line()
plt2 <- both_sexes %>% filter(race=='Whites') %>% 
    ggplot(aes(x = `Year of Diagnosis`, y  = rate, color = site))+
    geom_line()
plt3 <- both_sexes %>% filter(race=='Blacks') %>% 
    ggplot(aes(x = `Year of Diagnosis`, y  = rate, color = site))+
    geom_line()

library(cowplot)
plot_grid(plt1, 
          plot_grid(plt2, plt3, nrow=1,
                    labels = c('Whites','Blacks')),
          ncol=1,
          labels = c('Both races', ''))
```

</ol>

<div style="color: black; border:3px; border-style: solid; border-color: red;padding: 1em; background-color: wheat;font-size: 14pt;">
The code I developed in the screencast is available [here](HW3.R)
</div>
